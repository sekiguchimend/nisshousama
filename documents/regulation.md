# 開発・運用規則書

## 1. 命名規則

- **変数・関数**: camelCase
  - 例：`userName`, `getUserData`
- **クラス・型・コンポーネント**: PascalCase
  - 例：`UserProfile`, `OrderService`
- **定数**: UPPER_SNAKE_CASE
  - 例：`MAX_RETRY_COUNT`
- **ファイル名**: 小文字＋ハイフン区切り
  - 例：`user-profile.tsx`
- **ディレクトリ名**: 小文字複数形
  - 例：`components`, `features`

> 👉 **効果**: コードの可読性を統一し、後続開発や保守を容易にします。

## 2. 秘密情報管理

- 環境変数ファイル（`.env`）で管理、環境ごとに分離
- 本番環境は Secrets Manager / Parameter Store を利用
- 誤って秘匿情報をGitに登録した場合は即時ローテーション

> 👉 **効果**: 情報漏えいを未然に防ぎ、安全な運用を実現します。

## 3. 依存ライブラリ管理

- ロックファイルを必ず同梱し、再現可能なビルドを保証
- `npm audit` / `pnpm audit` にて High以上の脆弱性は検出時にブロック
- 不要なライブラリは定期的に削除

> 👉 **効果**: 使用する部品の安全性と安定性を維持します。

## 4. 型とデータ検証

- TypeScriptの strict モードを有効化
- `any` 型は原則禁止（例外は型ガード必須）
- API入出力は必ず DTOを定義し、zod / yup でバリデーション
- DBアクセスには Prisma / Supabase を使用し型安全を確保

> 👉 **効果**: 予期せぬデータ不整合を防ぎ、堅牢なシステムを保証します。

## 5. エラー処理とログ

- 全ての非同期処理に `try/catch` を実装
- エラーはドメイン別コードで分類
  - 例：`AUTH_001`, `DB_002`
- 個人情報はログに出力せず、必要時はマスク処理
- ログは CloudWatch や Datadog などの監視基盤へ送信

> 👉 **効果**: 障害発生時の迅速な原因追跡と、個人情報保護を両立します。

## 6. ディレクトリ構成

```
src/
├── components/   → UI部品（再利用可能）
├── features/     → 機能単位のまとまり
├── lib/          → 共通処理
├── pages/        → 画面定義（Next.jsの場合）
├── types/        → 型定義
└── tests/        → テストコード
```

> 👉 **効果**: 役割ごとに整理し、拡張性と保守性を確保します。

## 7. コード整形 / チェック

- ESLint（strictルールセット）と Prettier による自動整形
- CI/CD 上でLintチェックを実行し、不合格コードはマージ不可

> 👉 **効果**: スタイルを統一し、凡ミスを防止します。

## 8. テスト

- **ユニットテスト（Jest）**: 主要な関数・サービス層を対象
- **E2Eテスト（Playwright / Cypress）**: ログイン・CRUDなど主要フローを網羅
- **カバレッジ目標**: ユニット70%以上、E2Eは主要フロー100%通過

> 👉 **効果**: 本番環境リリース時の重大な不具合を未然に防ぎます。

## 9. コードレビュー / PRルール

- 原則、2名レビュー必須（小規模案件は1名＋CI合格で可）
- PRテンプレートで「目的」「変更点」「確認項目」を明記
- パフォーマンス問題（N+1クエリ等）はレビュー時に必ず確認
- `main` / `master` ブランチへの直接Pushは禁止

> 👉 **効果**: レビューを通じて品質を担保し、チーム全体で知識を共有します。

## 10. セキュリティ

- **認証**: OIDC/OAuth2、セッションは HttpOnly + SameSite=strict
- **認可**: RBAC（最小権限）、サーバー側で必ず検証
- **脆弱性対策**: CSRF / XSS / SQLi への対策をフレームワーク＋サーバー側で実装
- **データ保護**: 本番DBはAES-256で暗号化、通信はTLS必須
- **バックアップ**: 日次取得＋四半期ごとの復元テストを実施

> 👉 **効果**: 開発段階からセキュリティを組み込み、堅牢なシステムを提供します。

## gitリポジトリ再作成の手順

### 1. 現在の変更を保存（必要に応じて）
```bash
# 未コミットの変更がある場合、まず保存
git add .
git commit -m "作業中の変更を保存"
```

### 2. 既存の.gitディレクトリを削除
```bash
cd /Users/foxey/queue-work/dispatch-business-management-system
rm -rf .git
```

### 3. 新しいgitリポジトリを初期化
```bash
git init
```

### 4. リモートリポジトリを再設定
```bash
git remote add origin https://github.com/foxey151/dispatch-business-management-system.git
```

### 5. .gitignoreファイルを作成/確認
```bash
<code_block_to_apply_changes_from>
```

### 6. ファイルをステージング
```bash
git add .
```

### 7. 初回コミット
```bash
git commit -m "初回コミット: プロジェクト再構築"
```

### 8. メインブランチを設定
```bash
git branch -M main
```

### 9. リモートリポジトリにプッシュ
```bash
# 強制プッシュ（既存の履歴を上書き）
git push -u origin main --force
```

## 注意事項

⚠️ **重要**: この手順では既存のgit履歴が完全に削除されます。

- **バックアップ推奨**: 重要な履歴がある場合は、事前にバックアップを取ってください
- **チーム開発**: 他の開発者がいる場合は、事前に相談してください
- **強制プッシュ**: `--force` オプションはリモートリポジトリの履歴も上書きします

## 代替案: 履歴を保持したい場合

履歴を保持したい場合は、以下のような方法もあります：

```bash
# 新しいブランチで再構築
git checkout -b rebuild
git add .
git commit -m "プロジェクト再構築"
git push -u origin rebuild
```

この方法でよろしいでしょうか？何か特別な要件や質問がございましたら、お聞かせください。